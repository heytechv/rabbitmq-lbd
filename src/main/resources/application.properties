# -- Configuration of AWS/localstack --
#spring.rabbitmq.host=localhost
#spring.rabbitmq.port=5672
#spring.rabbitmq.username=user
#spring.rabbitmq.password=pass

# https://www.youtube.com/watch?v=q3zo3YREfJI
# https://github.com/maciejwalkowiak/spring-cloud-stream-binder-sqs/blob/master/spring-cloud-stream-binder-sqs-samples/simple-producer/src/main/resources/application.yml
cloud.aws.region.static=eu-central-1
cloud.aws.sqs.region=eu-central-1
cloud.aws.sns.region=eu-central-1
cloud.aws.credentials.access-key=foo
cloud.aws.credentials.secret-key=bar
cloud.aws.sns.endpoint=http://localhost:4566
cloud.aws.sqs.endpoint=http://localhost:4566
cloud.aws.sqs.enabled=true
#cloud.aws.stack.auto=false



# -- My RabbitMQ namespace --
#config.rabbitmq.userExchangeIn=user.input
config.rabbitmq.userExchangeIn=user.in
config.rabbitmq.userExchangeOut=user.out

config.rabbitmq.articleExchangeIn=article.in
config.rabbitmq.articleExchangeOut=article.out

config.rabbitmq.commentExchangeIn=comment.in
config.rabbitmq.commentExchangeOut=comment.out

config.rabbitmq.allOutput=all.out.queue

# -- Configuration of functions (exchanges) --
#spring.cloud.function.definition=userExchange;articleExchange;commentExchange;onReceive
spring.cloud.function.definition=onReceive

# -- Processor --
# Domyslnie tworzone sa kolejki o nazwie 'nazwaFunkcji-in/out-0'
# mozemy nazwy i konfiguracje overridowac
#
# spring.cloud.stream.bindings.userExchange-in-0.group=nazwa kolejki (queue)

## userExchange
# > Jeden wlasny input i wysyla do jednego wlasnego output
#spring.cloud.stream.bindings.userExchange-in-0.destination=${config.rabbitmq.userExchangeIn}
#spring.cloud.stream.bindings.userExchange-out-0.destination=${config.rabbitmq.userExchangeOut}
#spring.cloud.stream.bindings.userExchange-in-0.destination=userInQueue
#spring.cloud.stream.bindings.userExchange-out-0.destination=userOutQueue
    # nazwa kolejki dla input
#spring.cloud.stream.bindings.userExchange-in-0.group=MyQueue

# > lub jeden wlasny input i wysyla na jeden wspolny output
#spring.cloud.stream.bindings.userExchange-in-0.destination=${config.rabbitmq.userExchangeIn}
#spring.cloud.stream.bindings.userExchange-out-0.destination=${config.rabbitmq.allOutput}

### articleExchange
#spring.cloud.stream.bindings.articleExchange-in-0.destination=${config.rabbitmq.articleExchangeIn}
#spring.cloud.stream.bindings.articleExchange-out-0.destination=${config.rabbitmq.articleExchangeOut}
#spring.cloud.stream.bindings.commentExchange-in-0.group=queue
#
### commentExchange
#spring.cloud.stream.bindings.commentExchange-in-0.destination=${config.rabbitmq.commentExchangeIn}
#spring.cloud.stream.bindings.commentExchange-out-0.destination=${config.rabbitmq.commentExchangeOut}
#spring.cloud.stream.bindings.articleExchange-in-0.group=queue

# -- Consumer --
# > zbiera kazdy output z funkcji
#spring.cloud.stream.bindings.onReceive-in-0.destination=${config.rabbitmq.userExchangeOut},${config.rabbitmq.articleExchangeOut},${config.rabbitmq.commentExchangeOut}
spring.cloud.stream.bindings.onReceive-in-0.destination=test_queue
    # nazwa kolejki
spring.cloud.stream.bindings.onReceive-in-0.group=${config.rabbitmq.allOutput}
spring.cloud.stream.sqs.bindings.onReceive-in-0.consumer.snsFanout=false


    #
#spring.cloud.stream.rabbit.bindings.onReceive-in-0.consumer.bind-queue=true
    # zeby nie tworzyl wielu tylko jedna
#spring.cloud.stream.rabbit.bindings.onReceive-in-0.consumer.queueNameGroupOnly=true

# > lub jak bylo wysylane do jednego to z jednego
#spring.cloud.stream.bindings.onReceive-in-0.destination=${config.rabbitmq.allOutput}
#spring.cloud.stream.bindings.onReceive-in-0.group=consumer

